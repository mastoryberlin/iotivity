require "event_handler"
require "./resource"
require "./bindings"

module IoTivity

  # An IoTivity server.
  module Server
    include EventHandler

    # =======================================================================================
    # Events
    # =======================================================================================

    class RequestResponse < ::EventHandler::Event
      property status : OC::Status = OC::Status::MethodNotAllowed
      property response : String = ""
    end

    class_record Request < RequestResponse, uri : String, payload : String

    class GET    < Request; end
    class POST   < Request; end
    class PUT    < Request; end
    class DELETE < Request; end

    # =======================================================================================
    # Macros
    # =======================================================================================

    private def main(storage_dir)
      puts "No resources defined - set up the server using Server.register_resources before run"
    end

    # ---------------------------------------------------------------------------------------

    macro with_resources(hash)
      {%
        unless hash.is_a? HashLiteral
          raise "Argument 'hash' must be a Hash literal of the form
                 {uri => {rt: [types...], if: [ifs...]}, ...}"
        end
      %}

      private def main(storage_dir)
        # This is basically the Crystal translation of the C main() function
        # as it is generated by IoTivity's "gen.sh"

        # Allow Ctrl+C abortion but do proper cleanup
        Signal::INT.trap do
          @quit_server = true
        end

        puts "Set up an OCF Server"

        # intialize the variables
        puts "Initialize variables to defaults"
        Helper.initialize_variables

        # initialize the handlers structure
        handler = OC::Handler.new \
          init:               ->Helper.app_init,
          signal_event_loop:  ->{},
          register_resources: ->{
            {% for uri, tup in hash %}
              {% if uri.is_a? Path %}
                {% uri = uri.resolve %}
              {% end %}

              # Delegate parsing of interface and resource property string to a Resource struct
              %res = IoTivity::Resource.new {{uri}}, {{tup[:rt]}}, {{tup[:if]}},
                properties: \
                  {% if tup[:props].is_a? StringLiteral %}\
                    {{tup[:props]}}\
                  {% else %}\
                    IoTivity::ResourceProperties.flags( Discoverable, Periodic, Observable )\
                  {% end %}

              puts %{Register Resource with local path "{{uri.id}}"}
              %p = OC.new_resource nil, {{uri}}, {{tup[:rt].size}}, 0 # <- device no

              {% for t in tup[:rt] %}
              OC.resource_bind_resource_type %p, {{t}}
              {% end %}

              %res.interfaces.each { |i| OC.resource_bind_resource_interface %p, i }

              OC.resource_set_default_interface %p,
                %res.default_interface
              OC.resource_set_discoverable %p,
                %res.discoverable? ? 1 : 0
              OC.resource_set_observable %p,
                %res.observable? && !%res.periodic? ? 1 : 0
              OC.resource_set_periodic_observable %p,
                %res.periodic? && %res.observable? ? 1 : 0

              {% for method in [:GET, :POST, :PUT, :DELETE] %}
              OC.resource_set_request_handler %p, OC::Method::{{method.id}},
                ->(request, interface, data){
                  myself = Box(self).unbox data
                  rep = request.value.request_payload
                  size = OC.rep_to_json rep, nil, 0, 1
                  buf = Pointer(UInt8).malloc(size + 1)
                  OC.rep_to_json rep, buf, size + 1, 1
                  payload = String.new(buf)
                  e = myself.emit {{method.id}}, {{uri}}, payload
                  unless e.response.empty?
                    prepare_cbor e.response
                  end
                  OC.send_response request, e.status
                }, Helper.pServer
              {% end %}

              ret = OC.add_resource %p
              if ret.zero?
                raise "ERROR: Could not add resource #{%res.uri} to IoTivity stack (code #{ret})"
              end

            {% end %}
          }

        # #ifdef OC_SECURITY
        puts "Initialize Secure Resources\n"
        OC.storage_config storage_dir
        # #endif /* OC_SECURITY */

        # #ifdef OC_SECURITY
        # /* please comment out if the server:
        #   - have no display capabilities to display the PIN value
        #   - server does not require to implement RANDOM PIN (oic.sec.doxm.rdp) onboarding mechanism
        # */
        # oc_set_random_pin_callback(random_pin_cb, NULL);
        # #endif /* OC_SECURITY */

        OC.set_factory_presets_cb(->Helper.factory_presets_cb, nil)

        # start the stack
        init = OC.main_init(pointerof(handler))

        if init < 0
          puts "oc_main_init failed #{init}, exiting.\n"
          exit init;
        end

        puts "OCF server running, waiting on incoming connections.\n"

        # main loop
        until @quit_server
          OC.main_poll
          sleep 100.milliseconds
        end

        puts "Shutting down IoTivity..."
        OC.main_shutdown
      end

    end

    # =========================================================================
    # Instance variables
    # =========================================================================

    @quit_server = false

    # =========================================================================
    # Methods
    # =========================================================================

    # Sets up and runs the IoTivity server.
    def run_server(storage_dir)
      if storage_dir.is_a? Path
        storage_dir = storage_dir.to_s
      end

      Helper.pServer = Box.box self

      main(storage_dir)
    end

    # --------------------------------------------------------------------------

    def stop_server
      @quit_server = true
    end

  end # module Server

end # module Mastory::IoT
